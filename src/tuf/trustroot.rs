#![allow(dead_code)]

use base64::{engine::general_purpose::STANDARD as base64, Engine as _};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Deserializer};

fn deserialize_option_base64<'de, D>(de: D) -> std::result::Result<Option<Vec<u8>>, D::Error>
where
    D: Deserializer<'de>,
{
    let buf: Option<&str> = Deserialize::deserialize(de)?;

    match buf {
        Some(s) => Ok(Some(base64.decode(s).map_err(serde::de::Error::custom)?)),
        _ => Ok(None),
    }
}

fn deserialize_base64<'de, D>(de: D) -> std::result::Result<Vec<u8>, D::Error>
where
    D: Deserializer<'de>,
{
    let buf: &str = Deserialize::deserialize(de)?;

    base64.decode(buf).map_err(serde::de::Error::custom)
}

#[derive(Deserialize, PartialEq, Debug)]
#[allow(non_camel_case_types)]
pub(crate) enum HashAlgorithm {
    HASH_ALGORITHM_UNSPECIFIED = 0,
    SHA2_256 = 1,
}

#[derive(Deserialize, PartialEq, Debug)]
#[allow(non_camel_case_types)]
pub(crate) enum PublicKeyDetails {
    PUBLIC_KEY_DETAILS_UNSPECIFIED = 0,
    // RSA
    PKCS1_RSA_PKCS1V5 = 1, // See RFC8017
    PKCS1_RSA_PSS = 2,     // See RFC8017
    PKIX_RSA_PKCS1V5 = 3,
    PKIX_RSA_PSS = 4,
    // ECDSA
    PKIX_ECDSA_P256_SHA_256 = 5,      // See NIST FIPS 186-4
    PKIX_ECDSA_P256_HMAC_SHA_256 = 6, // See RFC6979
    // Ed 25519
    PKIX_ED25519 = 7, // See RFC8032
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct LogId {
    #[serde(deserialize_with = "deserialize_base64")]
    pub key_id: Vec<u8>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TimeRange {
    pub start: DateTime<Utc>,
    pub end: Option<DateTime<Utc>>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct PublicKey {
    #[serde(deserialize_with = "deserialize_option_base64")]
    pub raw_bytes: Option<Vec<u8>>,
    pub key_details: PublicKeyDetails,
    pub valid_for: Option<TimeRange>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct DistinguishedName {
    pub organization: String,
    pub common_name: String,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct X509Certificate {
    #[serde(deserialize_with = "deserialize_base64")]
    pub raw_bytes: Vec<u8>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct X509CertificateChain {
    pub certificates: Vec<X509Certificate>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransparencyLogInstance {
    pub base_url: String,
    pub hash_algorithm: HashAlgorithm,
    pub public_key: PublicKey,
    pub log_id: LogId,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct CertificateAuthority {
    pub subject: DistinguishedName,
    pub uri: Option<String>,
    pub cert_chain: X509CertificateChain,
    pub valid_for: TimeRange,
}

// HACK: We should probably use definitions from sigstore-protobuf-specs, but
// the autogenerated definitions are unergonomic. Declare it locally here.
#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TrustedRoot {
    pub media_type: String,
    pub tlogs: Vec<TransparencyLogInstance>,
    pub certificate_authorities: Vec<CertificateAuthority>,
    pub ctlogs: Vec<TransparencyLogInstance>,
    pub timestamp_authorities: Vec<CertificateAuthority>,
}
