#![allow(dead_code)]

// HACK(jl): protobuf-specs schemas are currently compiled for direct dependencies of the Bundle schema.
// See note https://github.com/sigstore/protobuf-specs/blob/main/gen/pb-rust/src/lib.rs#L1-L23
// HACK(ap): We should probably use definitions from sigstore-protobuf-specs, but
// the autogenerated definitions are unergonomic. Declare it locally here.

use base64::{engine::general_purpose::STANDARD as base64, Engine as _};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Deserializer, Serialize};
use serde_with::base64::{Base64, Bcrypt, BinHex, Standard};
use serde_with::formats::{Padded, Unpadded};
use serde_with::serde_as;

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub(crate) enum HashAlgorithm {
    HASH_ALGORITHM_UNSPECIFIED = 0,
    SHA2_256 = 1,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub(crate) enum PublicKeyDetails {
    PUBLIC_KEY_DETAILS_UNSPECIFIED = 0,
    // RSA
    PKCS1_RSA_PKCS1V5 = 1, // See RFC8017
    PKCS1_RSA_PSS = 2,     // See RFC8017
    PKIX_RSA_PKCS1V5 = 3,
    PKIX_RSA_PSS = 4,
    // ECDSA
    PKIX_ECDSA_P256_SHA_256 = 5,      // See NIST FIPS 186-4
    PKIX_ECDSA_P256_HMAC_SHA_256 = 6, // See RFC6979
    // Ed 25519
    PKIX_ED25519 = 7, // See RFC8032
}

#[serde_as]
#[serde(rename_all = "camelCase")]
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub(crate) struct LogId {
    #[serde_as(as = "Base64")]
    pub key_id: Vec<u8>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TimeRange {
    pub start: DateTime<Utc>,
    pub end: Option<DateTime<Utc>>,
}

#[serde_as]
#[serde(rename_all = "camelCase")]
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub(crate) struct PublicKey {
    #[serde_as(as = "Option<Base64>")]
    pub raw_bytes: Option<Vec<u8>>,
    pub key_details: PublicKeyDetails,
    pub valid_for: Option<TimeRange>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct DistinguishedName {
    pub organization: String,
    pub common_name: String,
}

#[serde_as]
#[serde(rename_all = "camelCase")]
#[derive(Serialize, Deserialize, Debug, PartialEq)]
pub(crate) struct X509Certificate {
    #[serde_as(as = "Base64")]
    pub raw_bytes: Vec<u8>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct X509CertificateChain {
    pub certificates: Vec<X509Certificate>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransparencyLogInstance {
    pub base_url: String,
    pub hash_algorithm: HashAlgorithm,
    pub public_key: PublicKey,
    pub log_id: LogId,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct CertificateAuthority {
    pub subject: DistinguishedName,
    pub uri: Option<String>,
    pub cert_chain: X509CertificateChain,
    pub valid_for: TimeRange,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TrustedRoot {
    pub media_type: String,
    pub tlogs: Vec<TransparencyLogInstance>,
    pub certificate_authorities: Vec<CertificateAuthority>,
    pub ctlogs: Vec<TransparencyLogInstance>,
    pub timestamp_authorities: Vec<CertificateAuthority>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn b64_serde() {
        let data = X509Certificate {
            raw_bytes: b"Hello World".to_vec(), // NOTE(jl): value not representative
        };
        let json = serde_json::json!({"rawBytes": "SGVsbG8gV29ybGQ=",});

        assert_eq!(json, serde_json::to_value(&data).unwrap());
        assert_eq!(data, serde_json::from_value(json).unwrap());
    }

    #[test]
    fn public_key_serde() {
        let data = PublicKey {
            raw_bytes: Some(b"Hello World".to_vec()),
            key_details: PublicKeyDetails::PKIX_ED25519,
            valid_for: Some(TimeRange {
                start: DateTime::from_timestamp(1_500_000_000, 0).unwrap(),
                end: None,
            }),
        };
        let json = serde_json::json!({
            "rawBytes": "SGVsbG8gV29ybGQ=",
            "keyDetails": "PKIX_ED25519",
            "validFor": {
                "start": "2017-07-14T02:40:00Z",
                "end": None::<DateTime<Utc>>
            }
        });

        assert_eq!(json, serde_json::to_value(&data).unwrap());
        assert_eq!(data, serde_json::from_value(json).unwrap());
    }
}
